// JoyceReversalMTF_Solo — Cloud-ready (Pepperstone cTrader Automate)
// Attached-symbol only (run one instance per instrument/timeframe).
// Strategy: HTF impulse+overlap → LTF breakout; both directions.
// Risk: Allocation = Equity/Parts (default 5). Risk at SL = Loss% of allocation.
// Exits: TP at impulse open with buffer (10%) or RR fallback; SL at confirm/impulse extreme + buffer.
// Safeguards: Max open positions (label-scoped) + Max Daily Loss % (realized PnL).

using System;
using cAlgo.API;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
public enum SLAnchor { ImpulseExtreme, ConfirmCandleExtreme }
public enum Dir { None, Buy, Sell }

[Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
public class JoyceReversalMTF_Solo : Robot
{
// ==== Trading toggles & guards ====
[Parameter("Enable Live Trading", DefaultValue = false)]
public bool EnableTrading { get; set; }

[Parameter("Max Open Positions (this symbol)", DefaultValue = 2, MinValue = 1)]
public int MaxOpenPositions { get; set; }

[Parameter("Max Daily Loss % of Equity", DefaultValue = 50.0, MinValue = 1.0, MaxValue = 100.0, Step = 1.0)]
public double MaxDailyLossPercent { get; set; }

// ==== Global thresholds (setup) ====
[Parameter("Min Impulse Body (pips)", DefaultValue = 10.0, MinValue = 0.0, Step = 0.5)]
public double MinImpulseBodyPips { get; set; }

[Parameter("Min Body/Range % (Impulse)", DefaultValue = 50.0, MinValue = 0, MaxValue = 100, Step = 1)]
public double MinBodyVsRangePercent { get; set; }

[Parameter("Confirm Overlap of Body %", DefaultValue = 25.0, MinValue = 1, MaxValue = 100, Step = 1)]
public double OverlapPercent { get; set; }

// ==== Allocation & risk ====
[Parameter("Use Equity/Parts Model", DefaultValue = true)]
public bool UseEquityParts { get; set; }

[Parameter("Parts (Equity ÷ Parts)", DefaultValue = 5, MinValue = 1)]
public int Parts { get; set; }

[Parameter("% of Equity as Allocation (if NOT using Parts)", DefaultValue = 20.0, MinValue = 0.1, MaxValue = 100.0, Step = 0.1)]
public double AllocationPercentOfEquity { get; set; }

[Parameter("Loss % of Allocation (risk at SL)", DefaultValue = 50.0, MinValue = 1.0, MaxValue = 100.0, Step = 1.0)]
public double LossPercentOfAllocation { get; set; }

// ==== Stops & targets ====
[Parameter("SL Anchor", DefaultValue = SLAnchor.ConfirmCandleExtreme)]
public SLAnchor StopAnchor { get; set; }

[Parameter("SL Buffer (pips)", DefaultValue = 2.0, MinValue = 0.0, Step = 0.1)]
public double StopBufferPips { get; set; }

[Parameter("TP = Impulse Open (buffered)", DefaultValue = true)]
public bool TpAtImpulseOpen { get; set; }

[Parameter("TP Buffer % at Impulse Open", DefaultValue = 10.0, MinValue = 0.0, MaxValue = 50.0, Step = 0.5)]
public double TpBufferPercent { get; set; }

[Parameter("Risk:Reward (if RR mode)", DefaultValue = 2.0, MinValue = 0.2, Step = 0.1)]
public double RiskReward { get; set; }

[Parameter("Max Confirm Bars (Lower TF)", DefaultValue = 60, MinValue = 1)]
public int MaxConfirmBars { get; set; }

// ==== Timeframe slots (use enums, not strings) ====
[Parameter("Slot A - Enabled", DefaultValue = true, Group = "Slot A")]
public bool SlotAEnabled { get; set; }
[Parameter("Slot A - Higher TF", DefaultValue = TimeFrame.Hour, Group = "Slot A")]
public TimeFrame SlotAHigherTF { get; set; }
[Parameter("Slot A - Confirm TF", DefaultValue = TimeFrame.Minute5, Group = "Slot A")]
public TimeFrame SlotAConfirmTF { get; set; }

[Parameter("Slot B - Enabled", DefaultValue = false, Group = "Slot B")]
public bool SlotBEnabled { get; set; }
[Parameter("Slot B - Higher TF", DefaultValue = TimeFrame.Minute30, Group = "Slot B")]
public TimeFrame SlotBHigherTF { get; set; }
[Parameter("Slot B - Confirm TF", DefaultValue = TimeFrame.Minute5, Group = "Slot B")]
public TimeFrame SlotBConfirmTF { get; set; }

[Parameter("Slot C - Enabled", DefaultValue = false, Group = "Slot C")]
public bool SlotCEnabled { get; set; }
[Parameter("Slot C - Higher TF", DefaultValue = TimeFrame.Minute15, Group = "Slot C")]
public TimeFrame SlotCHigherTF { get; set; }
[Parameter("Slot C - Confirm TF", DefaultValue = TimeFrame.Minute3, Group = "Slot C")]
public TimeFrame SlotCConfirmTF { get; set; }

// ==== Internals ====
private string _label;
private DateTime _currentDayUtc;
private double _startDayEquity;
private double _realizedPnLToday;

private class SlotState
{
public Bars HigherBars;
public Bars ConfirmBars;
public int LastProcessedHtfIndex = -1;

public bool PendingActive;
public Dir PendingDir;
public double Trigger;
public double ImpulseOpen;
public double ConfirmLow;
public double ConfirmHigh;
public double ImpulseLow;
public double ImpulseHigh;
public int ConfirmStartIdx;
}

private SlotState[] _slots = new SlotState[3];
private TimeFrame[] _slotHTF = new TimeFrame[3];
private TimeFrame[] _slotCTF = new TimeFrame[3];
private bool[] _slotEnabled = new bool[3];

protected override void OnStart()
{
_label = $"JoyceRev_{Account.Number}_{SymbolName}";
_currentDayUtc = DateTime.UtcNow.Date;
_startDayEquity = Account.Equity;
_realizedPnLToday = 0;

_slotEnabled[0] = SlotAEnabled; _slotHTF[0] = SlotAHigherTF; _slotCTF[0] = SlotAConfirmTF;
_slotEnabled[1] = SlotBEnabled; _slotHTF[1] = SlotBHigherTF; _slotCTF[1] = SlotBConfirmTF;
_slotEnabled[2] = SlotCEnabled; _slotHTF[2] = SlotCHigherTF; _slotCTF[2] = SlotCConfirmTF;

for (int i = 0; i < 3; i++)
{
if (!_slotEnabled[i]) continue;
_slots[i] = new SlotState
{
HigherBars = MarketData.GetBars(SymbolName, _slotHTF[i]),
ConfirmBars = MarketData.GetBars(SymbolName, _slotCTF[i]),
LastProcessedHtfIndex = -1,
PendingActive = false
};
Print("Slot {0}: {1} HTF={2}, CTF={3}", SlotName(i), SymbolName, _slotHTF[i], _slotCTF[i]);
}

Print("Trading {0}. Allocation: {1}",
EnableTrading ? "ENABLED" : "DISABLED",
UseEquityParts ? $"Equity/Parts (Parts={Parts})"
: $"{AllocationPercentOfEquity}% of equity; Loss%={LossPercentOfAllocation}% of allocation");
}

protected override void OnBar()
{
DailyResetIfNeeded();
for (int i = 0; i < 3; i++)
{
if (!_slotEnabled[i] || _slots[i] == null) continue;
BuildSetupIfAny(_slots[i]);
TryConfirmAndEnter(_slots[i], i);
}
}

protected override void OnTick()
{
DailyResetIfNeeded();
for (int i = 0; i < 3; i++)
{
if (!_slotEnabled[i] || _slots[i] == null) continue;
TryConfirmAndEnter(_slots[i], i);
}
}

protected override void OnPositionClosed(PositionClosedEventArgs args)
{
if (args.Position.Label == _label)
_realizedPnLToday += args.Position.GrossProfit;
}

private void DailyResetIfNeeded()
{
var d = DateTime.UtcNow.Date;
if (d != _currentDayUtc)
{
_currentDayUtc = d;
_startDayEquity = Account.Equity;
_realizedPnLToday = 0;
Print("New UTC day: daily loss counters reset.");
}
}

private bool DailyLossLimitHit()
{
double maxLoss = (_startDayEquity * MaxDailyLossPercent / 100.0);
return (-_realizedPnLToday) >= maxLoss;
}

private void BuildSetupIfAny(SlotState st)
{
var h = st.HigherBars;
if (h == null || h.Count < 3) return;

int last = h.Count - 1; // last CLOSED bar
if (last == st.LastProcessedHtfIndex) return;

int c = last; // confirmation candle
int i = c - 1; // impulse candle
if (i < 1) { st.LastProcessedHtfIndex = last; return; }

double iOpen = h.OpenPrices[i], iClose = h.ClosePrices[i], iHigh = h.HighPrices[i], iLow = h.LowPrices[i];
double cOpen = h.OpenPrices[c], cClose = h.ClosePrices[c], cHigh = h.HighPrices[c], cLow = h.LowPrices[c];

bool impulseRed = iClose < iOpen;
bool impulseGreen = iClose > iOpen;

double body = Math.Abs(iClose - iOpen);
double range = Math.Max(1e-12, iHigh - iLow);
double bodyPct = (body / range) * 100.0;
double minBodyPrice = MinImpulseBodyPips * Symbol.PipSize;
bool strong = body >= minBodyPrice || bodyPct >= MinBodyVsRangePercent;
if (!strong) { st.LastProcessedHtfIndex = last; return; }

double overlapFrac = Math.Max(0.0, Math.Min(1.0, OverlapPercent / 100.0));

if (impulseRed && cClose > cOpen)
{
double redBodyHeight = Math.Max(1e-12, iOpen - iClose);
double requiredClose = iClose + overlapFrac * redBodyHeight;
bool enteredBody = cOpen > iClose;
bool overlapped = cClose >= requiredClose;

if (enteredBody && overlapped)
{
st.PendingActive = true;
st.PendingDir = Dir.Buy;
st.Trigger = cHigh;
st.ImpulseOpen = iOpen;
st.ConfirmLow = cLow;
st.ConfirmHigh = cHigh;
st.ImpulseLow = iLow;
st.ImpulseHigh = iHigh;
st.ConfirmStartIdx = st.ConfirmBars != null ? st.ConfirmBars.Count - 1 : 0;
Print("BUY setup ready. Trigger>{0} | TP anchor (impulse open)={1}", st.Trigger, st.ImpulseOpen);
}
}

if (impulseGreen && cClose < cOpen)
{
double greenBodyHeight = Math.Max(1e-12, iClose - iOpen);
double requiredClose = iClose - overlapFrac * greenBodyHeight;
bool enteredBody = cOpen < iClose;
bool overlapped = cClose <= requiredClose;

if (enteredBody && overlapped)
{
st.PendingActive = true;
st.PendingDir = Dir.Sell;
st.Trigger = cLow;
st.ImpulseOpen = iOpen;
st.ConfirmLow = cLow;
st.ConfirmHigh = cHigh;
st.ImpulseLow = iLow;
st.ImpulseHigh = iHigh;
st.ConfirmStartIdx = st.ConfirmBars != null ? st.ConfirmBars.Count - 1 : 0;
Print("SELL setup ready. Trigger<{0} | TP anchor (impulse open)={1}", st.Trigger, st.ImpulseOpen);
}
}

st.LastProcessedHtfIndex = last;
}

private void TryConfirmAndEnter(SlotState st, int slotIdx)
{
if (!st.PendingActive || st.ConfirmBars == null || st.ConfirmBars.Count < 2) return;

if (DailyLossLimitHit())
{
st.PendingActive = false;
Print("Daily loss limit reached. No new entries.");
return;
}

if (CountOpenPositionsThisSymbol() >= MaxOpenPositions)
{
st.PendingActive = false;
Print("MaxOpenPositions reached ({0}). Skipping.", MaxOpenPositions);
return;
}

int nowIdx = st.ConfirmBars.Count - 1;
if (nowIdx - st.ConfirmStartIdx > MaxConfirmBars)
{
Print("Slot {0}: setup expired (>{1} bars).", SlotName(slotIdx), MaxConfirmBars);
st.PendingActive = false; return;
}

double sl = (StopAnchor == SLAnchor.ConfirmCandleExtreme)
? (st.PendingDir == Dir.Buy
? st.ConfirmLow - (StopBufferPips * Symbol.PipSize)
: st.ConfirmHigh + (StopBufferPips * Symbol.PipSize))
: (st.PendingDir == Dir.Buy
? st.ImpulseLow - (StopBufferPips * Symbol.PipSize)
: st.ImpulseHigh + (StopBufferPips * Symbol.PipSize));

if (st.PendingDir == Dir.Buy && Symbol.Bid < sl - 1e-8) { st.PendingActive = false; Print("BUY setup cancelled (SL anchor)."); return; }
if (st.PendingDir == Dir.Sell && Symbol.Ask > sl + 1e-8) { st.PendingActive = false; Print("SELL setup cancelled (SL anchor)."); return; }

bool breakout = (st.PendingDir == Dir.Buy) ? (Symbol.Ask > st.Trigger) : (Symbol.Bid < st.Trigger);
if (!breakout) return;

double entry = (st.PendingDir == Dir.Buy) ? Symbol.Ask : Symbol.Bid;
double slPips = Math.Abs(entry - sl) / Symbol.PipSize;
if (slPips <= 0) { st.PendingActive = false; return; }

double allocationCash = UseEquityParts ? Account.Equity / Math.Max(1, Parts)
: Account.Equity * (AllocationPercentOfEquity / 100.0);
double lossFrac = Math.Max(0.01, Math.Min(1.0, LossPercentOfAllocation / 100.0));
double riskCash = allocationCash * lossFrac;

double pipValuePerUnit = Symbol.PipValue / Symbol.LotSize;
if (pipValuePerUnit <= 0) { st.PendingActive = false; return; }

double rawUnits = riskCash / (slPips * pipValuePerUnit);
long units = Symbol.NormalizeVolumeInUnits(rawUnits, RoundingMode.Down);
if (units < Symbol.VolumeInUnitsMin)
{
Print("Slot {0}: volume {1} < min {2}. No trade.", SlotName(slotIdx), units, Symbol.VolumeInUnitsMin);
st.PendingActive = false; return;
}

double tpPrice;
if (TpAtImpulseOpen)
{
double bufferFrac = Math.Max(0.0, Math.Min(0.5, TpBufferPercent / 100.0));
if (st.PendingDir == Dir.Buy)
tpPrice = entry + (1.0 - bufferFrac) * (st.ImpulseOpen - entry);
else
tpPrice = entry - (1.0 - bufferFrac) * (entry - st.ImpulseOpen);

bool wrongSide = (st.PendingDir == Dir.Buy && tpPrice <= entry) ||
(st.PendingDir == Dir.Sell && tpPrice >= entry);
if (wrongSide)
tpPrice = (st.PendingDir == Dir.Buy)
? entry + RiskReward * (entry - sl)
: entry - RiskReward * (sl - entry);
}
else
{
tpPrice = (st.PendingDir == Dir.Buy)
? entry + RiskReward * (entry - sl)
: entry - RiskReward * (sl - entry);
}

int slPipsInt = (int)Math.Round(slPips);
int tpPipsInt = (int)Math.Round(Math.Abs(tpPrice - entry) / Symbol.PipSize);

if (!EnableTrading)
{
Print("[DRY RUN] Slot {0} {1} {2}u | Entry {3} | SL {4} ({5} pips) | TP {6} ({7} pips) | Alloc ${8:F2} | Risk ${9:F2}",
SlotName(slotIdx), st.PendingDir, units, entry, sl, slPipsInt, tpPrice, tpPipsInt, allocationCash, riskCash);
st.PendingActive = false; return;
}

var result = (st.PendingDir == Dir.Buy)
? ExecuteMarketOrder(TradeType.Buy, SymbolName, units, _label, slPipsInt, tpPipsInt)
: ExecuteMarketOrder(TradeType.Sell, SymbolName, units, _label, slPipsInt, tpPipsInt);

if (result.Error != ErrorCode.NoError)
Print("Slot {0}: order error: {1}", SlotName(slotIdx), result.Error);
else
Print("Slot {0}: {1} placed: {2}u | SL {3} | TP {4} | Alloc ${5:F2} | Risk ${6:F2}",
SlotName(slotIdx), st.PendingDir, units, sl, tpPrice, allocationCash, riskCash);

st.PendingActive = false;
}

private int CountOpenPositionsThisSymbol()
{
int n = 0;
foreach (var p in Positions)
if (p.SymbolName == SymbolName && p.Label == _label) n++;
return n;
}

private string SlotName(int idx) => idx == 0 ? "A" : idx == 1 ? "B" : "C";
}
}
